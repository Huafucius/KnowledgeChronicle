# 外星密码

## 题目描述

有了防护伞，并不能完全避免 2012 的灾难。地球防卫小队决定去求助外星种族的帮助。经过很长时间的努力，小队终于收到了外星生命的回信。但是外星人发过来的却是一串密码。只有解开密码，才能知道外星人给的准确回复。解开密码的第一道工序就是解压缩密码，外星人对于连续的若干个相同的子串 $\texttt{X}$ 会压缩为 $\texttt{[DX]}$ 的形式（ $D$ 是一个整数且 $1\leq D\leq99$），比如说字符串 $\texttt{CBCBCBCB}$ 就压缩为 $\texttt{[4CB]}$ 或者 $\texttt{[2[2CB]]}$，类似于后面这种压缩之后再压缩的称为二重压缩。如果是 $\texttt{[2[2[2CB]]]}$ 则是三重的。现在我们给你外星人发送的密码，请你对其进行解压缩。

## 输入格式

输入一行，一个字符串，表示外星人发送的密码。

## 输出格式

输出一行，一个字符串，表示解压缩后的结果。

## 样例 #1

### 样例输入 #1

```
AC[3FUN]
```

### 样例输出 #1

```
ACFUNFUNFUN
```

## 提示

【数据范围】

对于 $50\%$ 的数据：解压后的字符串长度在 $1000$ 以内，最多只有三重压缩。

对于 $100\%$ 的数据：解压后的字符串长度在 $20000$ 以内，最多只有十重压缩。保证只包含数字、大写字母、`[` 和 `]`。

## 题解

### 题目分析

主体可以一个个读取字符，遇到压缩包则进行解压缩操作。

因为可能有多层压缩，每个压缩包都可以看作一个规模较小的**子问题**，递归进行读取操作：

$$主串 = 正常部分 + n * 压缩包子串 + 正常部分......$$

$$压缩包子串 = 一个较小的主串$$

也就是说，在遇到压缩包时，让一个（递归）函数去处理`[]`中的字符串，我们只负责把解压缩后的字符串复制n次拼接到主串上。

这样，函数将会递归直到该压缩包内部没有下一层压缩包，并直接返回字符串本体。

### AC代码

```c++
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;

// 核心递归函数read
string read() {
	string str, sub_str; 	// 当前位置的主串，以及存储解压信息的子串
	int n; // 解压时压缩次数
	char c;// 读取的字符

	// 循环读取
	while (cin >> c) {
		// 第一种情况，开始压缩包
		if (c == '[') {
			cin >> n;                  // 读取次数n
			sub_str = read();          // 读取子串sub_str（子串可能递归解压）
			while(n--) str += sub_str; // 拼接到主串，完成解压
		}

		// 第二种情况，结束压缩包，鉴定为压缩结束，返回主串
		else if (c == ']') {
			return str;
		}

		// 第三种情况，普通字符，直接拼接
		else {
			str += c;
		}
	}
	return str;
}

// 主函数
int main() {
	cout << read();
	return 0;
}
```
