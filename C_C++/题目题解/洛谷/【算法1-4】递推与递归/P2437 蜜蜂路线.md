# 蜜蜂路线

## 题目背景

无

## 题目描述

一只蜜蜂在下图所示的数字蜂房上爬动,已知它只能从标号小的蜂房爬到标号大的相邻蜂房,现在问你：蜜蜂从蜂房 $m$ 开始爬到蜂房 $n$ , $m < n$ ，有多少种爬行路线？（备注：题面有误，右上角应为 $n-1$）

![](https://cdn.luogu.com.cn/upload/pic/1575.png)

## 输入格式

输入 $m,n$ 的值

## 输出格式

爬行有多少种路线

## 样例 #1

### 样例输入 #1

```
1 14
```

### 样例输出 #1

```
377
```

## 提示

对于100%的数据， $1 \le M,N\le 1000$

## 题解

### 题目分析

又一个高精度的斐波那契数列，继续练习高精度加法的写法。在coding过程中因为一些小细节WA了几次，一定要注意：

1. 去除前导零最好用一个单独的`while`循环进行，否则可能会出一些奇怪的错误。
2. 对于这种数据规模较小的题目，可以直接开大的二维数组，节省时间。如果数据规模较大，则考虑换成滚动数组。
3. 高精度加法的关键在于`digit`和`carry`两个变量，先把它们设出来并单独在循环中计算，这样后续处理的时候逻辑可以更加清晰。

接下来展示一些自己的错误，引以为鉴。

### WA代码（跳过前导零）

本部分功能为在最后输出时跳过前导零。

```c++
	for (int i = MAX_LEN - 1; i >= 0; --i) {
		if (ans[n][i] == 0)
			continue;
		printf("%d", ans[n][i]);
	}
}
```

注意到这个部分，不止前导零，它把所有的零全都跳过了。一定不要图方便这么写，跳过前导零乖乖一行`while`循环，代码运行快才是真正的好，把所有逻辑压缩到几行那是狗屎代码。

### AC代码

```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int MAX_LEN = 2000; // 预设最大长度

int ans[1005][MAX_LEN] = {}; // 二维数组存储每个格子的方法数

int main() {
	int m, n;
	cin >> m >> n;

	// 初始化，从第m个格子开始，它有1种方法
	ans[m][0] = ans[m + 1][0] = 1;

	// 高精度加法的斐波那契循环。注意把digit和carry单独写出来，这样可以提升自己编写代码时的清晰度。
	int digit = 0, carry = 0;
	for (int i = m; i <= n - 2; ++i) {
		// 高精度加法部分，加法、进位、更新进位，三步一气呵成。
		for (int j = 0; j < MAX_LEN; ++j) {
			digit = ans[i][j] + ans[i + 1][j] + carry;
			ans[i + 2][j] = digit % 10;
			carry = digit / 10;
		}
	}

	// 输出并去除前导零部分，注意一定要单独一个while来执行去除前导零的操作，否则很有可能出错。
	int index = MAX_LEN - 1;
	while (index > 0 && ans[n][index] == 0) --index;
	while (index >= 0) {
		printf("%d", ans[n][index]);
		--index;
	}
}
```
