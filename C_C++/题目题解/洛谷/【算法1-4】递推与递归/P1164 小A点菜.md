# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。

## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。

## 输入格式

第一行是两个数字，表示 $N$ 和 $M$。

第二行起 $N$ 个正数 $a_i$（可以有相同的数字，每个数字均在 $1000$ 以内）。

## 输出格式

一个正整数，表示点菜方案数，保证答案的范围在 int 之内。

## 样例 #1

### 样例输入 #1

```
4 4
1 1 2 2
```

### 样例输出 #1

```
3
```

## 提示

2020.8.29，增添一组 hack 数据 by @yummy

## 题解

### 题目分析

一道非常基础典型的dp题目。观察到有n道菜，m元钱，求解方法数。使用price[i]记录第i道菜的金额。我们可以逐步考虑，在只考虑前i道菜时，花费j元钱的方法数。

考虑第i道菜。显然，对于一道菜，只有买与不买两种操作。如果不买，则钱数不变，继承j元钱方法数；如果买，则继承j-price[i]的方法数，因为此时买这个菜后，就会变成花费j元钱。

注意，我已默认降维，若不明白可自行查看洛谷题解，我只记录自己的心得部分。

转移方程为： $dp[j] = dp[j] + dp[j - price[i]]$ ，第一项是不买，第二项是买。

### WA代码

第一次提交WA了，原因是把里面price[i]写成price[j]了。一定小心！可以找找哪里写错了。可以多设几个中间变量，尽量一行只处理一件事情，别下标套下标、表达式套表达式，太容易乱。

```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

int M, N;
int price[110]; // 用于存储价格信息
int dp[10010];  // 下标为花费的钱数，值为方法数

int main() {
	cin >> M >> N;
	for (int i = 0; i < N; ++i)
		cin >> price[i];

	dp[0] = 1;
	for (int i = 0; i < N; ++i) {
		for (int j = M; j >= price[j]; --j) {
				dp[j] = dp[j] + dp[j - price[i]];
		}
	}

	cout << dp[M];
}
```

### AC代码

```c++
#include <iostream>
using namespace std;

int m, n; // 分别代表剩余的钱和菜品种数
int price[110]; // 存储每种菜的价格
int dp[10010] = { 0 }; // dp[i]表示用i元钱的点菜方法数

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; ++i) {
        cin >> price[i];
    }

    dp[0] = 1; // 初始化，0元钱的点菜方法只有一种，即什么都不点
    for (int i = 0; i < n; ++i) {
        for (int j = m; j >= price[i]; --j) {
            dp[j] += dp[j - price[i]]; // 更新dp数组
        }
    }

    cout << dp[m]; // 输出用m元钱的点菜方法数
    return 0;
}
```
